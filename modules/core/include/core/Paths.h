#pragma once
#include "Platform.h"
#include "config.h" // The header generated by CMake
#include <filesystem>
#include <optional>

namespace RDE {
    inline std::optional<std::filesystem::path> get_asset_path() {
        auto exe_path = Platform::get_executable_path();
        if (!exe_path.has_value()) {
            RDE_CORE_WARN("No executable path found");
            return std::nullopt; // Failed to find executable
        }
        auto exe_dir = exe_path->parent_path();

        // 1. Try the installed/packaged path first.
        //    (e.g., ../share/YourGameName/assets relative to the exe in bin/)
        auto installed_path = exe_dir / ".." / "share" / "YourGameName" / "assets";
        if (std::filesystem::exists(installed_path)) {
            return installed_path;
        }

        // 2. Fall back to the development path (if defined).
        //    This uses the path baked in by CMake from the source tree.
#ifdef RDE_DEVELOPMENT_ASSET_PATH
        RDE_CORE_INFO("RDE_DEVELOPMENT_ASSET_PATH: {}", RDE_DEVELOPMENT_ASSET_PATH);
        std::filesystem::path dev_path(exe_dir / RDE_DEVELOPMENT_ASSET_PATH);
        RDE_CORE_INFO("Trying dev_path: {}", dev_path.string());
        if (std::filesystem::exists(dev_path)) {
            return dev_path;
        }
#endif
        
        // 3. Last resort: try a simple relative path (will often fail, but better than nothing).
        auto simple_relative_path = exe_dir / "assets";
        RDE_CORE_INFO("Trying simple_relative_path: {}", simple_relative_path.string());
        if (std::filesystem::exists(simple_relative_path)) {
            return simple_relative_path;
        }

        return std::nullopt; // Could not find assets
    }
}